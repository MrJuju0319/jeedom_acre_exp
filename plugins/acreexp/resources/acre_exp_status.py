#!/usr/bin/env python3
"""Utility script used by the Jeedom ACRE SPC plugin.

The script reads the minimal YAML configuration file generated by the
plugin, logs on the SPC Web Gateway and retrieves the current state of
areas and zones.  The code purposely avoids any third party dependency so
that it can run on a vanilla Jeedom installation.
"""
from __future__ import annotations

import argparse
import json
import os
import sys
import time
import traceback
from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Mapping, Optional

try:
    import requests
    from requests import RequestException
except Exception as exc:  # pragma: no cover - safety net if requests is missing
    raise SystemExit(json.dumps({"error": f"Python requests module is required: {exc}"}))

try:
    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
except Exception:
    pass


class SimpleYamlParser:
    """Very small YAML subset parser.

    The PHP side only generates scalar values and nested dictionaries, so a
    tiny hand written parser is enough.  Values are treated as strings unless
    they clearly represent numbers or booleans.
    """

    def __init__(self, content: str) -> None:
        self._lines: List[str] = [line.rstrip() for line in content.splitlines() if line.strip() != ""]
        self._index = 0

    def parse(self) -> Dict[str, Any]:
        return self._parse_block(expected_indent=0)

    def _parse_block(self, expected_indent: int) -> Dict[str, Any]:
        result: Dict[str, Any] = {}
        while self._index < len(self._lines):
            line = self._lines[self._index]
            indent = len(line) - len(line.lstrip(" "))
            if indent < expected_indent:
                break
            if indent > expected_indent:
                raise ValueError(f"Invalid indentation at line {self._index + 1}")

            self._index += 1
            if ":" not in line:
                raise ValueError(f"Invalid entry at line {self._index}")

            key, raw_value = line.split(":", 1)
            key = key.strip()
            value = raw_value.strip()

            if value == "":
                # Nested structure
                result[key] = self._parse_block(expected_indent=expected_indent + 2)
            else:
                result[key] = self._convert_scalar(value)
        return result

    @staticmethod
    def _convert_scalar(value: str) -> Any:
        lowered = value.lower()
        if lowered in {"true", "false"}:
            return lowered == "true"
        # Numeric detection
        try:
            if value.startswith("0") and value != "0":
                # keep as string to avoid stripping leading zero (PIN codes)
                return value
            return int(value)
        except ValueError:
            try:
                return float(value)
            except ValueError:
                pass
        if value.startswith("'") and value.endswith("'"):
            return value[1:-1].replace("''", "'")
        return value


def load_config(path: str) -> Dict[str, Any]:
    try:
        with open(path, "r", encoding="utf-8") as handle:
            content = handle.read()
    except OSError as exc:
        raise SystemExit(json.dumps({"error": f"Unable to read configuration file: {exc}"}))

    try:
        data = SimpleYamlParser(content).parse()
    except Exception as exc:
        raise SystemExit(json.dumps({"error": f"Invalid configuration file: {exc}"}))

    return data


@dataclass
class SpcConfig:
    host: str
    user: str
    pin: str
    session_cache_dir: Optional[str] = None

    @classmethod
    def from_mapping(cls, mapping: Mapping[str, Any]) -> "SpcConfig":
        try:
            spc = mapping["spc"]
        except KeyError as exc:
            raise SystemExit(json.dumps({"error": f"Missing configuration section: {exc}"}))
        if not isinstance(spc, Mapping):
            raise SystemExit(json.dumps({"error": "Invalid configuration structure (spc)"}))

        host = str(spc.get("host", "")).strip()
        user = str(spc.get("user", "")).strip()
        pin = str(spc.get("pin", "")).strip()
        session_cache_dir = spc.get("session_cache_dir")
        if session_cache_dir is not None:
            session_cache_dir = str(session_cache_dir)

        missing: List[str] = [
            name for name, value in (("host", host), ("user", user), ("pin", pin)) if not value
        ]
        if missing:
            raise SystemExit(json.dumps({"error": f"Missing required configuration values: {', '.join(missing)}"}))

        return cls(host=host, user=user, pin=pin, session_cache_dir=session_cache_dir)


@dataclass
class SpcSessionStore:
    directory: Optional[str]
    _filename: Optional[str] = field(init=False, default=None)

    def __post_init__(self) -> None:
        if self.directory:
            try:
                os.makedirs(self.directory, exist_ok=True)
            except OSError:
                # We can still continue without cache persistence
                self.directory = None

    @property
    def filename(self) -> Optional[str]:
        if self.directory is None:
            return None
        if self._filename is None:
            self._filename = os.path.join(self.directory, "session.json")
        return self._filename

    def load(self) -> Optional[Dict[str, Any]]:
        path = self.filename
        if not path or not os.path.exists(path):
            return None
        try:
            with open(path, "r", encoding="utf-8") as handle:
                return json.load(handle)
        except Exception:
            return None

    def save(self, data: Mapping[str, Any]) -> None:
        path = self.filename
        if not path:
            return
        tmp_path = f"{path}.tmp"
        try:
            with open(tmp_path, "w", encoding="utf-8") as handle:
                json.dump(data, handle)
            os.replace(tmp_path, path)
        except Exception:
            # Cache persistence failure is not fatal
            pass


class SpcClient:
    """Minimal SPC Web Gateway client implementing login, watchdog and status."""

    def __init__(self, config: SpcConfig, timeout: float = 30.0) -> None:
        self._config = config
        self._timeout = timeout
        self._session = requests.Session()
        self._session.verify = False  # The SPC Web Gateway often uses self-signed certificates.
        self._session.headers.update({"Accept": "application/json"})
        self._store = SpcSessionStore(config.session_cache_dir)
        self._load_cached_session()

    def _load_cached_session(self) -> None:
        cached = self._store.load()
        if not cached:
            return
        cookies = cached.get("cookies")
        timestamp = cached.get("timestamp")
        if not cookies or not isinstance(cookies, Mapping):
            return
        if timestamp and time.time() - float(timestamp) > 3600:
            return
        for name, value in cookies.items():
            self._session.cookies.set(name, value)

    def _save_session(self) -> None:
        cookies = {cookie.name: cookie.value for cookie in self._session.cookies}
        data = {"cookies": cookies, "timestamp": time.time()}
        self._store.save(data)

    def _url(self, path: str) -> str:
        base = self._config.host.rstrip("/")
        if not base.startswith("http://") and not base.startswith("https://"):
            base = f"https://{base}"
        return f"{base}/{path.lstrip('/')}"

    def _request_with_fallback(
        self,
        method: str,
        candidates: Iterable[str],
        retry_login: bool = True,
        **kwargs: Any,
    ) -> Any:
        errors: List[str] = []
        for candidate in candidates:
            try:
                return self._request_json(method, candidate, retry_login=retry_login, **kwargs)
            except Exception as exc:
                errors.append(f"{candidate}: {exc}")
        raise RuntimeError("All endpoints failed: " + "; ".join(errors))

    def _request_json(self, method: str, path: str, retry_login: bool = True, **kwargs: Any) -> Any:
        url = self._url(path)
        try:
            response = self._session.request(method, url, timeout=self._timeout, **kwargs)
        except RequestException as exc:
            raise RuntimeError(f'HTTP request failed on {path}: {exc}')
        if response.status_code in (401, 403) and retry_login:
            self.login(force=True)
            return self._request_json(method, path, retry_login=False, **kwargs)
        if response.status_code >= 400:
            raise RuntimeError(f"HTTP {response.status_code} on {path}: {response.text[:200]}")
        try:
            payload = response.json()
        except ValueError as exc:
            raise RuntimeError(f"Invalid JSON payload on {path}: {exc}")
        return payload

    def login(self, force: bool = False) -> None:
        if not force and self._session.cookies:
            try:
                self.watchdog()
                return
            except Exception:
                pass

        self._session.cookies.clear()
        payloads: List[Mapping[str, Any]] = [
            {"user": self._config.user, "pin": self._config.pin},
            {"username": self._config.user, "password": self._config.pin},
            {"user": self._config.user, "password": self._config.pin},
            {"username": self._config.user, "pin": self._config.pin},
        ]
        errors: List[str] = []
        for body in payloads:
            for mode in ("json", "data"):
                try:
                    kwargs = {mode: body}
                    data = self._request_with_fallback(
                        "POST",
                        ["/spc/login", "/login"],
                        retry_login=False,
                        **kwargs,
                    )
                except Exception as exc:
                    errors.append(str(exc))
                    continue
                if self._is_login_success(data):
                    self._save_session()
                    return
                errors.append(f"Login attempt failed with payload {mode} {body} -> {data}")

        raise RuntimeError("Unable to authenticate on SPC: " + "; ".join(errors))

    @staticmethod
    def _is_login_success(payload: Any) -> bool:
        if isinstance(payload, Mapping):
            if payload.get("status") in ("success", "ok", 0, "0"):
                return True
            if isinstance(payload.get("status"), Mapping):
                status = payload["status"]
                code = status.get("code")
                if code in (0, "0", "success"):
                    return True
                if status.get("str", "").lower() in {"ok", "success"}:
                    return True
        return False

    def watchdog(self) -> None:
        try:
            data = self._request_json("POST", "/spc/control/watchdog", json={})
        except Exception:
            data = self._request_with_fallback("GET", ["/spc/control/watchdog", "/spc/watchdog"])
        if not self._is_generic_success(data):
            raise RuntimeError(f"Watchdog rejected: {data}")

    def _is_generic_success(self, payload: Any) -> bool:
        if isinstance(payload, Mapping):
            if payload.get("status") in ("success", "ok", 0, "0"):
                return True
            status = payload.get("status")
            if isinstance(status, Mapping):
                code = status.get("code")
                text = str(status.get("str", "")).lower()
                if code in (0, "0", "success"):
                    return True
                if text in {"ok", "success"}:
                    return True
        return False

    def get_status(self) -> Dict[str, Any]:
        self.login()
        status_payload = self._request_with_fallback("GET", ["/spc/status", "/spc/status/system", "/status"])
        areas_payload = self._request_with_fallback("GET", ["/spc/status/area", "/spc/area", "/area"])
        zones_payload = self._request_with_fallback("GET", ["/spc/status/zone", "/spc/zone", "/zone"])

        self._save_session()

        return {
            "status": self._extract_result(status_payload),
            "areas": self._normalise_list(self._extract_result(areas_payload)),
            "zones": self._normalise_list(self._extract_result(zones_payload)),
        }

    def _extract_result(self, payload: Any) -> Any:
        if isinstance(payload, Mapping):
            if "data" in payload:
                return payload["data"]
            if "result" in payload:
                return payload["result"]
        return payload

    @staticmethod
    def _normalise_list(value: Any) -> List[Dict[str, Any]]:
        if isinstance(value, Mapping):
            # Some gateways return {"list": [...]}
            if "list" in value and isinstance(value["list"], Iterable):
                return [SpcClient._ensure_mapping(item) for item in value["list"]]
            return [SpcClient._ensure_mapping(value)]
        if isinstance(value, Iterable):
            return [SpcClient._ensure_mapping(item) for item in value]
        return []

    @staticmethod
    def _ensure_mapping(value: Any) -> Dict[str, Any]:
        if isinstance(value, Mapping):
            return dict(value)
        return {"value": value}


def parse_args(argv: Optional[Iterable[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Retrieve SPC status snapshot")
    parser.add_argument("-c", "--config", required=True, help="Path to the generated configuration YAML")
    parser.add_argument("--debug", action="store_true", help="Print full stacktrace on error")
    return parser.parse_args(argv)


def main(argv: Optional[Iterable[str]] = None) -> int:
    args = parse_args(argv)
    config_dict = load_config(args.config)
    spc_config = SpcConfig.from_mapping(config_dict)

    client = SpcClient(spc_config)
    try:
        snapshot = client.get_status()
    except Exception as exc:
        if args.debug:
            traceback.print_exc()
        print(json.dumps({"error": str(exc)}))
        return 1

    print(json.dumps(snapshot))
    return 0


if __name__ == "__main__":
    sys.exit(main())
